# Possible future work for Mattak

* feature set control
* break into crates
* features on `mattak` crate to incorporate sub-crates
* push errors down
* make error handling sensible
* considered approach re IRIs vs URIs

* sqlxmq standard parts?

## Routing

* For the URITemplate/matchit "bridge"
  - consider adding the ability to "trade" '//' for a limit of 1 pre-path
    expression
* Good documentation of our URITemplate/matchit frankenstein language
* elsewhere, the Elm URITemplate library I'm using doesn't cover level 4
  * replace?
  * extend?

## Authentication

* Build general purpose resources for auth/registration
  * Or maybe a central auth service?
* Pull mailing and sqlxmq from WtP
  * Mail needs configuration
  * sqlxmq needs to be able to share its migrations
* Need some kind of interface for Revocations and Users - DB agnostic?
* auth keypair rotation
* keyset keypair tracking
* revocation dissemination
  * add a revoke-serial to biscuits
  * downstream can compare to their revoke list and fetch new ones if needed
* token renewal (and time-based attenuation)
* IP association - at least "issued_remote_ip" and let application check
  * problem here is NAT on the client side and proxying on the server side
  * trust X-Forwarded-For ?
    * ...from a particular IP/range? My purposes, "trust forwarded-for from 127.0.0.1"

* need to decide on a Authorization: scheme - bearer probably okay/correct for biscuits
* consider a SPAKE over HTTP though for the initial auth

## Ratelimiting

* Consider building a replacement for tower_governor - the underlying leaky bucket is good,
  but the layer configuration is too agnostic.

== Design Decisions

Progressive JSON-LD - use JSON-LD compatible fields as we go,
with the idea that we notionally have a @context.
Maybe someday we do this for real and build things out.
Minimize the amount of adjustment that takes.

pJSON-LD - use "id" and "type" etc
because "@id" requires extra serde macros to make work.
In our "notional" @context, we could `id: @id` to "fix" it.

Each B/E resource needs an IriTemplate field that describes how to get back there,
plus some SKOS Notations with the fields for it.
This lets the F/E embed the Notations into the browser address,
and then (e.g.) if reloaded/URL shared, fill in the template with the notations
to reload the data from the backend.
Open question: how to address user-context data?
(sharing the games for an event should show you your interests, not mine.)

JSON-LD _technically_ doesn't allow typemaps of scalars - IOW, where it would be nice to be able to say
notation: {
  event: <id>,
  user: <id>,
}
and have "event" and "user" be @contexted as datatype IRIs, JSON-LD doesn't expand that way.
*For the time being* we'll do that _anyway_ and if at some point we come in the validated fold,
we can adjust how we process SKOS notations as more verbose structures.
Per [JSON-LD spec](https://www.w3.org/TR/json-ld/#typed-values)
the context could describe the SKOS types for a nickname, so I think this should be okay
long term.

Important question: what does JSON-LD/Hydra get us beyond design guidelines?
Once it's properly documented (i.e. @context Link headers etc),
we get a published schema that implementers can refer to.
Ideally, we're able to construct something in Rust that lets us ship @context documents
automatically, including RDF:Classes for our DTOs.


It's tempting, always to set up macros or something for what feel like
repetitive fields in the DB/HTTP DTOs. Some real wins with flattened sub-structs
in the DB, since the underlying tables are going imply some repetition,
making DB DTOs generic over Id types is a big win.
But! especially on the HTTP side,
generics and macros limit the flexibility of the API
by making seemingly related resources advance in lock-step.
In WTP we are seeing now a relationship between User and Profile
(that is: other folks at this event, and your own data.)
There's also relationships between every list/item pair.
These make it tempting to build general List/Item responses,
or #[derive(ListResponse)] or whatever.
However, every time I've considered that, it seems to me that every
remaining part of the similar-looking resources are a point of variability.
Breaking down elements that should be made automatic
from those that should allow human expression in their variation
is a key part of the design here, and needs to be considered carefully.

== Design Findings

In general: the DB side of things
can be templated/automated to the degree it makes sense.
Overdoing it will be felt quickly, and the concern is completely about
making ergonomic queries of the database.

HTTP DTOs should err on the side of repetition.
Duplicating code now leaves room for variation later.
Interactions with the client are going to be the most painful to unpick.

Routing remains an area of interest.
